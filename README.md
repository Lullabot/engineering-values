# Lullabot’s Engineering Values

At Lullabot, we’re a team with a wide variety of backgrounds coming together to build systems to solve complex problems. We combine strategy, user interface design, and code, into cohesive software designs. Together, these types of work form a practice of software engineering. You may not think of yourself as an engineer, but what we do at Lullabot collectively is engineering. When we say engineering, we mean you.

These Engineering Values exist to guide our team in the work we produce and the interactions we have with each other. These values overlap and expand on our Core Values - they’re not a hierarchy or a tree. When solutions aren’t obvious, or there’s conflict, we use these values to ground our decisions.

# People matter more

We build systems and processes for people first—and if we forget or ignore those people, our systems become a source of dread, rather than a source of delight. A project that launches on time and on budget, but burns out a team, isn’t successful. Helping others when opportunities appear keeps us connected, even when we’re separated by great distances.

# Cultivate inclusivity

We value diversity and inclusion. Beyond its intrinsic value, inclusion has an impact on a technical level. Our overarching goal is to identify or to be the experts and advocates for people who are not directly represented by our project teams. For example, we seek out the voice of the end-user, because client perspectives can sometimes miss key factors that only a user would know. We work towards equitable teams so that our work reflects the diverse world in which we live. And, we continuously evaluate and respond to feedback, because the voices that are missing are going to be different from project to project.

We cultivate inclusivity at a technical level by building accessible products because the work we do should function for everyone. Sometimes that means educating our clients about the importance of accessibility. Further, we aspire to work using tools that are accessible themselves and seek to use accessible language and technologies in our documentation so that differently-abled people can work on both sides of the keyboard.

# Embrace open-source

Innovation doesn’t come from keeping secrets. We aim to have out-sized impacts on the products we work on by fully participating in the free and open source software community. We share our work to thank the community software we are building on, to allow for critiques of our work, and to force ourselves to keep innovating.

# Learn and share

We find our work fulfilling because we are always given the opportunity to learn something new. We like to work on new, unsolved problems over applying the same solutions to the same problems. Learning, and sharing what we learn, is woven through all the work we do day by day.

We believe that the best engineering comes from sharing and building together as a group. We don’t want to have to solve the same problem more than once. By sharing our struggles and what we learn, we create the space for our team to ask for help and to be generous with their knowledge.

# Do no harm

The work we produce is not separate from the world in which we live. We value human safety and security. While we do not always have direct control over how our work is used, we aim to create products that do not actively harm any one group. We draw on our empathy to build tools and products that equitably empower everyone who uses them, considering the impact of unintended consequences.

# Perfect is the enemy of “good enough”

We find the balance between getting things done and architectural zen. When we solve tricky software engineering problems, we also consider when we are seeing diminishing returns. Rather than creating in isolation, we iterate using real-world feedback and quantitative results to evaluate our work.

# Strive for excellence

We don’t just want to get the work done—we want to feel good about what we’ve delivered. Even as we improve our technical skills, we should be able to say, “we did the best work we could with the resources and knowledge we had at the time.”

# Maximize value for the client

We strive for excellence because that’s what we consider best for our clients. However, we don’t make these decisions alone. We involve our clients to ensure we help them reach their goals. Some projects need tactical engineering measures that are not meant to last. Other times, we discover new information, and we need to stop working to discuss the options again. We acknowledge that we encounter non-ideal scenarios, but we work with our clients to find out what works best for their project.

# Code for the future

Creating a system to solve a complex problem is only the first part of a software project. Good systems last because they are maintainable and also maximize value for the client. Others will inherit our work and need to improve and maintain it. We don’t have perfect memory and know that sometimes the inheritors are just “future us.” We optimize code for future readers, even if that means using more verbose language or limiting the use of uncommon language features.

# Joyful tinkering

As engineers, we have a tendency to look at technical challenges as fun puzzles to be solved rather than problems. While every developer weeps onto their keyboard from time to time, we know that the satisfaction of finding the location of that obscure missing semicolon that broke everything is the ultimate triumph. We try things, we break things, and we try again.

# Engage people, not tools

In our work, we use many tools as a means of communication, such as instant messaging apps, project management apps, version control, and peer review workflows. Sometimes, the tools we use to communicate can be a blunt instrument for human dialog. We strive to be aware of the limitations of the tools we use and keep in mind that they are a means to engage people and not an end in themselves.

# Automate without over-engineering

We delight in automating away repetition for ourselves, the community, and our clients. Automation promises to reduce technical debt in our code, make our processes more robust, and save time and money. However, automation can also add unnecessary complexity and waste time. Therefore, we must be skeptical of automation. Just because we can automate something doesn’t mean we should. We consider the following when automating our work:

| Reasons to automate                                           | Considerations                                                              |
| ------------------------------------------------------------- | --------------------------------------------------------------------------- |
| Deliver a better product                                      | How long will it take for the investment to pay off? How much will it cost? |
| Improve the developer experience                              | How many developers are there? How much time remains in the project?        |
| A greater need for consistency and stability over flexibility | Is it likely to introduce new, more complex errors?                         |
| Solve a business need                                         | Does it align with the goals of the project?                                |
| Document and codify a process for future teams                | Does documentation serve as enough “automation” for the team?               |
| Reduce technical debt                                         | Does it match the desired complexity of the rest of the project?            |

# Work joy into work

We work together to foster a delightful and positive work environment. This empowers us to find possibilities instead of problems, and the courage to accept criticism with an open mind. Even amid extreme technical challenges, we find something to smile about—whether that’s a new skill learned, a helpful teammate, or wistfully deleting code we loved. Together, we smile in the face of adversity, freeing us to find elegant solutions to the toughest problems.
